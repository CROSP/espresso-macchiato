plugins {
    id 'pl.allegro.tech.build.axion-release' version '1.3.4'
    id "co.riiid.gradle" version "0.4.2"
}
apply plugin: 'com.android.library'
apply plugin: 'com.novoda.bintray-release'

android {
    compileSdkVersion 23
    buildToolsVersion "23.0.3"

    defaultConfig {
        // v8 ist lowest min sdk which supported by espresso
        minSdkVersion 8
        targetSdkVersion 23

        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
        debug {
            // support code coverage for testing
            testCoverageEnabled = true
        }
    }
    lintOptions {
        // ignore InvalidPackage for JUnit, this library will only be a test dependency
        disable 'InvalidPackage'
    }
}

dependencies {
    compile 'com.android.support.test.espresso:espresso-contrib:2.2.2'
    compile 'com.android.support.test.espresso:espresso-intents:2.2.2'
    // real uiautomator is not available inside Android Studio when used as compile dependency
    provided project(':uiautomator')

    androidTestCompile 'com.android.support.test.uiautomator:uiautomator-v18:2.1.2'
}

// Original see: http://ryanharter.com/blog/2013/07/30/automatic-versioning-with-git-and-gradle/
def currentReleaseTag = { ->
    def stdout = new ByteArrayOutputStream()
    exec {
        commandLine 'git', 'describe', '--tags', '--match', 'release*'
        standardOutput = stdout
        ignoreExitValue = true
    }
    def releaseTag = stdout.toString().trim()
    return releaseTag ? releaseTag : "release-0.0.0"
}

// plugin configuration to publish release artifacts to bintray
publish {
    groupId = 'de.nenick'
    artifactId = 'espresso-macchiato'
    publishVersion = currentReleaseTag().replace("release-", "")
    desc = 'Oh hi, this is a nice description for a project, right?'
    website = 'https://github.com/nenick/espresso-macchiato'
    licences = ['AML'] // AML = MIT license http://spdx.org/licenses/
    autoPublish = true
}

// plugin configuration to create release tag and push to github
scmVersion {
    tag {
        prefix = 'release'
    }
}

// plugin configuration to publish release artifacts to github
github {
    //noinspection GroovyAssignabilityCheck
    owner = project.hasProperty("githubUser") ? project.property("githubUser") : "undefined"
    repo = 'espresso-macchiato'
    token = project.hasProperty("githubKey") ? project.property("githubKey") : "undefined"
    tagName = currentReleaseTag()
    targetCommitish = 'master'
    name = currentReleaseTag()
    body = new File('RELEASE_NOTES.md').text
    assets = ['library/build/outputs/aar/library-release.aar']
}

// Custom connectedCheck task without uninstall
// https://android.googlesource.com/platform/tools/build/+/3c6ba532ac7618701123629906a854c157ae59c0/gradle/src/main/groovy/com/android/build/gradle/internal/tasks/DeviceProviderInstrumentTestTask.groovy
// https://android.googlesource.com/platform/tools/base/+/8d969614b7beca74e4d17f2d1c5956e75053f7ce/build-system/builder/src/main/java/com/android/builder/internal/testing/SimpleTestCallable.java
// http://grepcode.com/file/repo1.maven.org/maven2/com.google.android.tools/ddmlib/r10/com/android/ddmlib/AndroidDebugBridge.java
// https://android.googlesource.com/platform/tools/base/+/tools_r22/ddmlib/src/main/java/com/android/ddmlib/testrunner/RemoteAndroidTestRunner.java

import com.android.build.gradle.internal.test.report.ReportType
import com.android.build.gradle.internal.test.report.TestReport
import com.android.builder.internal.testing.CustomTestRunListener
import com.android.ddmlib.AndroidDebugBridge
import com.android.ddmlib.IDevice
import com.android.ddmlib.IShellOutputReceiver
import com.android.ddmlib.testrunner.RemoteAndroidTestRunner
import com.android.utils.ILogger

task connectedCheckRunTests << {
    def applicationId = "de.nenick.espressomacchiato.test"

    String adbCommand = android.getAdbExe().absolutePath
    String coverageFileOnDevice = "${applicationId}/coverage.ec";
    String testApk = "library/build/outputs/apk/library-debug-androidTest-unaligned.apk"

    // define all output directories
    def testResultXmlOutputDirectory = file("build/outputs/androidTest-results/connected")
    def testResultHtmlOutputDirectory = file("build/reports/androidTests/connected")
    def coverageOutputDirectory = file("build/outputs/code-coverage/connected")

    // initial clear all output directories (force failures if one step failed unexpectedly)
    testResultXmlOutputDirectory.deleteDir()
    testResultHtmlOutputDirectory.deleteDir()
    coverageOutputDirectory.deleteDir()

    // create some expected output directories (some steps would fail without them)
    testResultXmlOutputDirectory.mkdirs()
    coverageOutputDirectory.mkdirs()

    // without started adb we can not find any devices
    exec {
        commandLine adbCommand
        args = ["start-server"]
    }

    // prepare connection for all connected devices and emulators
    AndroidDebugBridge.initIfNeeded(false /*clientSupport*/)
    AndroidDebugBridge bridge = AndroidDebugBridge.createBridge(adbCommand, false /*forceNewBridge*/)

    // wait until all connected devices are collected, original from https://android.googlesource.com/platform/tools/build/+/master/builder/src/main/java/com/android/builder/testing/ConnectedDeviceProvider.java
    long timeOut = 30000 // 30 sec
    int sleepTime = 1000
    while (!bridge.hasInitialDeviceList() && timeOut > 0) {
        sleep(sleepTime)
        timeOut -= sleepTime
    }
    if (timeOut <= 0 && !bridge.hasInitialDeviceList()) {
        throw new RuntimeException("Timeout getting device list.", null)
    }
    IDevice[] devices = bridge.devices
    if (devices.length == 0) {
        throw new RuntimeException("No connected devices!", null)
    }

    // current it is enough to just take the first device (loop to support more devices)
    def device = AndroidDebugBridge.createBridge().devices[0]
    String deviceName = device.getName();

    def runner = new RemoteAndroidTestRunner(applicationId, "android.support.test.runner.AndroidJUnitRunner", AndroidDebugBridge.createBridge().devices[0])
    runner.addInstrumentationArg("coverage", "true");
    runner.addInstrumentationArg("coverageFile", coverageFileOnDevice);
    runner.setRunName(deviceName);


    def listener = new CustomTestRunListener(deviceName, "myProject", "myflavor", new ILogger() {
        @Override
        void error(Throwable throwable, String s, Object... objects) {
            logger.error(String.format(s, objects), throwable)
        }

        @Override
        void warning(String s, Object... objects) {
            logger.warn(String.format(s, objects))
        }

        @Override
        void info(String s, Object... objects) {
            logger.lifecycle(String.format(s, objects))
        }

        @Override
        void verbose(String s, Object... objects) {
            logger.lifecycle(String.format(s, objects))
        }
    })

    listener.setReportDir(testResultXmlOutputDirectory)

    device.installPackage(testApk, true /* reinstall */)
    runner.run(listener)

    // finish and pull coverage data from device
    device.executeShellCommand("am broadcast -a ${applicationId}.END_EMMA", new IShellOutputReceiver() {
        @Override
        void addOutput(byte[] bytes, int i, int i1) {

        }

        @Override
        void flush() {

        }

        @Override
        boolean isCancelled() {
            return false
        }
    })
    exec {
        commandLine android.getAdbExe().absolutePath
        args = ["pull", coverageFileOnDevice, coverageOutputDirectory.absolutePath + "/coverage.ec"]
    }

    TestReport report = new TestReport(ReportType.SINGLE_FLAVOR, testResultXmlOutputDirectory, testResultXmlOutputDirectory)
    report.generateReport()

    //device.uninstallPackage(applicationId)
}
afterEvaluate {
    tasks.connectedCheckRunTests.dependsOn tasks.assembleDebugAndroidTest
}


apply plugin: "jacoco"

// https://github.com/srideviaishwariya/Automation-Tools-for-Android/tree/master/Sample1
task jacocoTestReportAndroid(type: JacocoReport) {
    def coverageSourceDirs = [
            'src/main/java'
    ]
    group = "Reporting"
    description = "Generates Jacoco coverage reports"
    reports {
        xml.enabled = true
        xml.destination = "${buildDir}/reports/jacoco/jacoco.xml"
        html.enabled = true
        html.destination = "${buildDir}/reports/coverage/debug"
    }
    file(reports.xml.destination).deleteDir()
    file(reports.html.destination).deleteDir()

    classDirectories = fileTree(
            dir: 'build/intermediates/classes',
            excludes: ['**/R.class',
                       '**/R$*.class',
                       '**/BuildConfig.*'
            ]
    )
    sourceDirectories = files(coverageSourceDirs)
    additionalSourceDirs = files(coverageSourceDirs)
    executionData = files('build/outputs/code-coverage/connected/coverage.ec')
}

task connectedCheckScreenshot {
    dependsOn tasks.connectedCheckRunTests, tasks.jacocoTestReportAndroid
}